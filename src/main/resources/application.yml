server:
  port: @server.port@
spring:
  application:
    name: @project.name@
  output:
    ansi:
      enabled: always
  kafka:
    bootstrap-servers: "localhost:29092"
    admin:
      client-id: "fault-detector"
      ssl:
        trust-store-type: "PKCS12"
        trust-store-location: "src/main/resources/cert/truststore.p12"
        trust-store-password: "kenny12"
        key-store-password: "kenny"
        key-password: "kenny"
        key-store-location: "src/main/resources/cert/keystore.p12"
        key-store-type: "PKCS12"
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: dev.vality.faultdetector.serializer.ServiceOperationSerializer

    consumer:
      group-id: @project.name@
      max-poll-records: 300
      fetch-min-size: 1024
      fetch-max-wait: 1000
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: dev.vality.faultdetector.serializer.ServiceOperationDeserializer
      auto-offset-reset: earliest
    listener:
      concurrency: 1


info:
  version: @project.version@
  stage: dev

operations:
  preAggregationPeriod: 3000
  useServiceConfigPreAggregationPeriod: false
  schedulerPoolSize: 2
  metricsCheckPeriod: 5000
  metricsInitialDelayPeriod: 5000

kafka:
  consumer:
    topic: "fault-detector"
    reconnect-backoff-ms: 15000
    reconnect-backoff-max-ms: 30000
    retry-backoff-ms: 1000

management:
  security:
    flag: false
  server:
    port: '@management.port@'
  metrics:
    export:
      prometheus:
        enabled: true
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
    prometheus:
      enabled: true
  endpoints:
    web:
      exposure:
        include: health,info,prometheus
